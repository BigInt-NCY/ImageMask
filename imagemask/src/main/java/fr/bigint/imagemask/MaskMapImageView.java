package fr.bigint.imagemask;

import android.content.Context;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Matrix;
import android.graphics.drawable.Drawable;
import android.os.AsyncTask;
import android.support.annotation.ArrayRes;
import android.support.annotation.DrawableRes;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.widget.ImageView;

import java.lang.ref.WeakReference;

/**
 * <p>
 * ImageView subclass that maps touch events to some areas of the displayed
 * image. Areas are described by {@link Mask} classes. You can init mappings
 * from XML like so:</p><p>
 * <em>layout file</em>:
 * <pre>{@code
 * <fr.bigint.imagemask.MaskMapImageView
 *     android:layout_width="wrap_content"
 *     android:layout_height="wrap_content"
 *     android:scaleType="fitCenter"
 *     android:src="@drawable/image"
 *     mask:masks="@array/image_masks"
 *     mask:mask_type="includeColor"
 *     mask:mask_color="#FFFFFFFF"
 *     mask:mask_weight="0.5"
 *     mask:mask_showDebugOverlay="false"/>
 * }</pre>
 * <em>mappings.xml</em>
 * <pre>{@code
 * <resources>
 *     <integer-array name="body_masks">
 *         <item>@drawable/mask1</item>
 *         <item>@drawable/mask2</item>
 *         <item>@drawable/mask3</item>
 *     </integer-array>
 * </resources>
 * }</pre>
 * </p>
 * <ul>
 *     <li><em>masks</em> is a reference to the array of drawables
 *     contained in <em>mappings.xml</em>. These drawables will
 *     be used by this class to generate bit masks in order to map
 *     touch events. If this attribute is not defined there will
 *     be no mapping generated by the view.</li>
 *
 *     <li><em>mask_type</em> attribute defines the way masks will
 *     be created from drawables. This attribute can take 4 values:
 *     <em>{@link MaskConfig#OPACITY_MASK "opacity"}</em>,
 *     <em>{@link MaskConfig#TRANSPARENCY_MASK "transparency"}</em>,
 *     <em>{@link MaskConfig#INCLUDE_COLOR_MASK "includeColor"}</em> or
 *     <em>{@link MaskConfig#EXCLUDE_COLOR_MASK "excludeColor"}</em>.
 *     Default value: <em>{@link MaskConfig#OPACITY_MASK "opacity"}</em>.
 *     </li>
 *
 *     <li><em>mask_color</em> defines the color used to create masks
 *     when <em>mask_type</em> is
 *     {@link MaskConfig#INCLUDE_COLOR_MASK "includeColor"}
 *     or {@link MaskConfig#EXCLUDE_COLOR_MASK "excludeColor"}.
 *     Default value: #00000000.</li>
 *
 *     <li><em>mask_weight</em> defines the relative weight of the mask
 *     in memory. By default the weight is 1.0 which means that 1 pixel
 *     of the drawable supplied to create the mask will occupy 1 bit in
 *     memory. You can set the weight in ]0, 1] interval in which case
 *     the mask will occupy (weight) * 1 bit per pixel. Warning: the
 *     precision of the mask will decrease as well. Make sure your mask
 *     is still correct using {@link #setDebugOverlayEnabled debug overlay}.
 *     </li>
 *
 *     <li><em>mask_showDebugOverlay</em>: if true the debug overlay will
 *     be printed onto the image see {@link #setDebugOverlayEnabled} for
 *     details. Default value is false.</li>
 * </ul>
 * <p>
 *     You can init mapping programmatically like so:
 * </p>
 * <pre>{@code
 * MaskDefinition[] maskDefinitions = {
 *      new MaskDefinition(R.drawable.mask_red, MaskConfig.getIncludeColorMaskConfig(0xffff0000, 1), "red"),
 *      new MaskDefinition(R.drawable.mask_green, MaskConfig.getIncludeColorMaskConfig(0xff00ff00, 1), "green"),
 *      new MaskDefinition(R.drawable.mask_blue, MaskConfig.getIncludeColorMaskConfig(0xff0000ff, 1), "blue")
 * };
 * maskMapImageView.setMasks(maskDefinitions);
 * }</pre>
 * <p>
 *     For more details on masks see {@link MaskDefinition} and {@link MaskConfig}.
 * </p>
 * <p>
 *     In order to listen touch events relative to masks you can register
 *     a listener with {@link #setOnMaskTouchListener(OnMaskTouchListener)}
 * </p>
 *
 * @attr ref R.styleable#MaskMapImageView_masks
 * @attr ref R.styleable#MaskMapImageView_mask_type
 * @attr ref R.styleable#MaskMapImageView_mask_color
 * @attr ref R.styleable#MaskMapImageView_mask_weight
 * @attr ref R.styleable#MaskMapImageView_mask_showDebugOverlay
 *
 * @author Felicien Brochu
 * @version 1.0
 *
 * @see Mask
 * @see MaskConfig
 * @see MaskDefinition
 */
public class MaskMapImageView extends ImageView {
	/**
	 * Masks definitions used to init masks.
	 */
	private MaskDefinition[] mMaskDefinitions;

	/**
	 * Masks used to map areas.
	 */
	private Mask[] mMasks;

	/**
	 * Default configuration used to init
	 * masks when no per-mask
	 * {@link MaskDefinition#maskConfig configuration}
	 * is provided in a {@link MaskDefinition}.
	 */
	private MaskConfig mDefaultMaskConfig;

	/**
	 * Lock used on {link #mMasks} access.
	 */
	private final Object mMasksLock = new Object();

	/**
	 * Last pressed mask.
	 */
	private Mask mPressedMask;

	private OnMaskTouchListener mOnMaskTouchListener;


	private boolean mDebugOverlayEnabled = false;

	/**
	 * Array of colors (bitmap) used to draw
	 * the debug overlay when enabled.
	 */
	private int[] mDebugOverlay;

	/**
	 * Worker task that initializes the debug overlay
	 */
	private InitDebugOverlayTask mInitDebugOverlayTask;



	public MaskMapImageView(Context context) {
		this(context, null);
	}

	public MaskMapImageView(Context context, @Nullable AttributeSet attrs) {
		this(context, attrs, 0);
	}

	public MaskMapImageView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
		super(context, attrs, defStyleAttr);

		TypedArray a = context.getTheme().obtainStyledAttributes(
				attrs,
				R.styleable.MaskMapImageView,
				defStyleAttr, 0);

		try {
			int masks = a.getResourceId(R.styleable.MaskMapImageView_masks, 0);
			int maskType = a.getInteger(R.styleable.MaskMapImageView_mask_type, 1);
			int maskColor = a.getColor(R.styleable.MaskMapImageView_mask_color, 0x00000000);
			float maskWeight = a.getFloat(R.styleable.MaskMapImageView_mask_weight, 1f);
			mDebugOverlayEnabled = a.getBoolean(R.styleable.MaskMapImageView_mask_showDebugOverlay, false);

			int maskConfigType;

			switch (maskType) {
				case 1:
					maskConfigType = MaskConfig.OPACITY_MASK;
					break;
				case 2:
					maskConfigType = MaskConfig.TRANSPARENCY_MASK;
					break;
				case 3:
					maskConfigType = MaskConfig.INCLUDE_COLOR_MASK;
					break;
				case 4:
					maskConfigType = MaskConfig.EXCLUDE_COLOR_MASK;
					break;
				default:
					maskConfigType = MaskConfig.OPACITY_MASK;
			}

			if (maskWeight > 1 || maskWeight <= 0) {
				throw new IllegalArgumentException("Attribute mask_weight must be strictly greater than 0 and less or equal to 1.");
			}

			mDefaultMaskConfig = new MaskConfig(maskConfigType, maskWeight, maskColor);
			if (masks != 0) {
				if (!getResources().getResourceTypeName(masks).equals("array")) {
					throw new IllegalArgumentException("Attribute masks must be an array resource");
				}
				setMasks(mDefaultMaskConfig, masks);
			}
		} finally {
			a.recycle();
		}
	}

	@Override
	/**
	 * {@inheritDoc}
	 */
	public boolean onTouchEvent(MotionEvent event) {
		boolean eventHandled = false;

		if (event.getAction() == MotionEvent.ACTION_DOWN) {
			mPressedMask = getMatchingMask(event.getX(), event.getY());

			if (mPressedMask != null) {
				notifyMaskPressedEvent(mPressedMask);
				eventHandled = true;
			}
		} else if (event.getAction() == MotionEvent.ACTION_UP) {
			Mask touchedMask = getMatchingMask(event.getX(), event.getY());
			if (mPressedMask == touchedMask && mPressedMask != null) {
				notifyMaskUnpressedEvent(touchedMask);
				notifyMaskClickEvent(mPressedMask);
				eventHandled = true;
			}
			mPressedMask = null;
		} else if (event.getAction() == MotionEvent.ACTION_MOVE) {
			Mask touchedMask = getMatchingMask(event.getX(), event.getY());
			if (touchedMask != mPressedMask && mPressedMask != null) {
				notifyMaskUnpressedEvent(mPressedMask);
				mPressedMask = null;
			}
		} else if (mPressedMask != null) {
			notifyMaskUnpressedEvent(mPressedMask);
			mPressedMask = null;
		}

		if (eventHandled) {
			return true;
		} else {
			return super.onTouchEvent(event);
		}
	}

	/**
	 * Returns the matching mask for the
	 * given local view coordinates. If no
	 * mask is matched, it returns null.
	 *
	 * @param x x coordinate in local pixels
	 * @param y y coordinate in local pixels
	 * @return the matching mask for the
	 * given local view coordinates, null if none.
	 */
	@Nullable
	public Mask getMatchingMask(float x, float y) {
		synchronized (mMasksLock) {
			if (mMasks == null) {
				return null;
			}
			Mask.Point maskPoint = getMaskPoint(x, y);

			for (Mask mask : mMasks) {
				if (mask.matches(maskPoint)) {
					return mask;
				}
			}
		}

		return null;
	}

	/**
	 * Returns the mask point for the given
	 * coordinates of the view.
	 *
	 * @param x x coordinate in local pixels
	 * @param y y coordinate in local pixels
	 * @return the mask point corresponding to
	 * x and y coordinates of the view.
	 */
	private Mask.Point getMaskPoint(float x, float y) {
		Mask.Point maskPoint;

		if (getScaleType() == ScaleType.FIT_XY) {
			maskPoint = getFitXYMaskPoint(x, y);
		} else {
			maskPoint = getDefaultMaskPoint(x, y);
		}
		return maskPoint;
	}

	private Mask.Point getFitXYMaskPoint(float x, float y) {
		float[] imageMatrix = new float[9];
		getImageMatrix().getValues(imageMatrix);

		final float translateX = imageMatrix[Matrix.MTRANS_X];
		final float translateY = imageMatrix[Matrix.MTRANS_Y];

		float maskX = (x - getPaddingLeft() - translateX) / (getWidth() - getPaddingLeft() - getPaddingRight());
		float maskY = (y - getPaddingTop() - translateY) / (getHeight() - getPaddingTop() - getPaddingBottom());

		return new Mask.Point(maskX, maskY);
	}

	private Mask.Point getDefaultMaskPoint(float x, float y) {
		float[] imageMatrix = new float[9];
		getImageMatrix().getValues(imageMatrix);

		final float scaleX = imageMatrix[Matrix.MSCALE_X];
		final float scaleY = imageMatrix[Matrix.MSCALE_Y];
		final float translateX = imageMatrix[Matrix.MTRANS_X];
		final float translateY = imageMatrix[Matrix.MTRANS_Y];

		final Drawable drawable = getDrawable();
		final int drawableWidth = drawable.getIntrinsicWidth();
		final int drawableHeight = drawable.getIntrinsicHeight();

		final int imageWidth = Math.round(drawableWidth * scaleX);
		final int imageHeight = Math.round(drawableHeight * scaleY);

		float maskX = (x - getPaddingLeft() - translateX) / imageWidth;
		float maskY = (y - getPaddingTop() - translateY) / imageHeight;

		return new Mask.Point(maskX, maskY);
	}

	@Override
	/**
	 * {@inheritDoc}
	 */
	protected void onDraw(Canvas canvas) {
		super.onDraw(canvas);

		if (mDebugOverlayEnabled) {
			drawDebugOverlay(canvas);
		}
	}

	@Override
	protected void onSizeChanged(int w, int h, int oldw, int oldh) {
		super.onSizeChanged(w, h, oldw, oldh);

		invalidateDebugOverlay();
	}

	private void invalidateDebugOverlay() {
		initDebugOverlay();
	}

	private void drawDebugOverlay(Canvas canvas) {
		canvas.save();
		if (mDebugOverlay == null) {
			initDebugOverlay();
		} else {
			canvas.drawBitmap(mDebugOverlay, 0, getWidth(), 0, 0, getWidth(), getHeight(), true, null);
		}
		canvas.restore();
	}

	private void initDebugOverlay() {
		synchronized (mMasksLock) {
			if (mMasks != null && mMasks.length > 0) {
				if (mInitDebugOverlayTask != null) {
					mInitDebugOverlayTask.cancel(true);
					mDebugOverlay = null;
				}
				mInitDebugOverlayTask = new InitDebugOverlayTask(this, getWidth(), getHeight());
				mInitDebugOverlayTask.execute(mMasks);
			}
		}
	}

	private void notifyMaskPressedEvent(@NonNull Mask mask) {
		if (mOnMaskTouchListener != null) {
			mOnMaskTouchListener.onMaskPressed(mask.getDrawableMask(), mask.getTag());
		}
	}

	private void notifyMaskUnpressedEvent(@NonNull Mask mask) {
		if (mOnMaskTouchListener != null) {
			mOnMaskTouchListener.onMaskUnpressed(mask.getDrawableMask(), mask.getTag());
		}
	}

	private void notifyMaskClickEvent(@NonNull Mask mask) {
		if (mOnMaskTouchListener != null) {
			mOnMaskTouchListener.onMaskClick(mask.getDrawableMask(), mask.getTag());
		}
	}

	/**
	 * Init mapping from drawable masks. maskConfig
	 * parameter is used as config for all masks and
	 * becomes the default configuration.
	 *
	 * @param maskConfig Configuration used to create
	 *                   masks from drawables
	 * @param masks      Array resource of drawable ids
	 *                   used to create masks
	 * @see #setMasks(MaskDefinition...)
	 */
	public void setMasks(MaskConfig maskConfig, @ArrayRes int masks) {
		try {
			TypedArray drawableArray = getResources().obtainTypedArray(masks);
			int[] masksIds = new int[drawableArray.length()];

			for (int i = 0; i < drawableArray.length(); i++) {
				masksIds[i] = drawableArray.getResourceId(i, 0);
			}

			drawableArray.recycle();
			setMasks(maskConfig, masksIds);

		} catch (Resources.NotFoundException exception) {
			throw new IllegalArgumentException("Paramter masks must be an array resource", exception);
		}
	}

	/**
	 * Init mapping from drawable masks. maskConfig
	 * parameter is used as config for all masks and
	 * becomes the default configuration.
	 *
	 * @param maskConfig    Configuration used to create
	 *                      masks from drawables
	 * @param drawableMasks Resource ids of drawables
	 *                      used to create masks
	 * @see #setMasks(MaskDefinition...)
	 */
	public void setMasks(@NonNull MaskConfig maskConfig, @DrawableRes int... drawableMasks) {
		mDefaultMaskConfig = maskConfig;
		setMasks(drawableMasks);
	}

	/**
	 * Init mapping from drawable masks. The default
	 * configuration is used to create all masks.
	 *
	 * @param drawableMasks Resource ids of drawables
	 *                      used to create masks
	 * @see #setMasks(MaskDefinition...)
	 */
	public void setMasks(@DrawableRes int... drawableMasks) {
		MaskDefinition[] maskDefinitions = new MaskDefinition[drawableMasks.length];
		for (int i = 0; i < maskDefinitions.length; i++) {
			maskDefinitions[i] = new MaskDefinition(drawableMasks[i], mDefaultMaskConfig, null);
		}
		setMasks(maskDefinitions);
	}

	/**
	 * Init mapping from {@link fr.bigint.imagemask.MaskDefinition MaskDefinition}.
	 * Each mask will be created asynchronously according
	 * to its {@link fr.bigint.imagemask.MaskDefinition MaskDefinition}.
	 * Each mask is stored as a bitmask in memory:
	 * 1 pixel = 1 bit. If the {@link fr.bigint.imagemask.MaskConfig#weight weight}
	 * is less than 1 the bitmask will weight less
	 * in memory: 1 pixel = weight * 1 bit. Precision
	 * of the mask will decrease though.
	 *
	 * @param maskDefinitions Mapping masks definitions.
	 */
	public void setMasks(@NonNull MaskDefinition... maskDefinitions) {
		clearMasks();
		mMaskDefinitions = maskDefinitions;
		initMasks();
	}

	/**
	 * Clear all masks and cancel all asynchronous
	 * initialization of masks currently running.
	 */
	public void clearMasks() {
		synchronized (mMasksLock) {
			if (mMasks != null) {
				for (Mask mask : mMasks) {
					mask.cancelInitTask();
				}
				mMasks = null;
			}
			mMaskDefinitions = null;
		}
	}

	/**
	 * Asynchronously init the masks.
	 */
	protected void initMasks() {
		synchronized (mMasksLock) {
			mMasks = new Mask[mMaskDefinitions.length];

			for (int i = 0; i < mMaskDefinitions.length; i++) {
				MaskDefinition definition = mMaskDefinitions[i];
				Mask mask = new Mask(definition);
				mMasks[i] = mask;
				mask.initAsync(getContext());
			}
		}
	}

	/**
	 * If enabled, a transparent overlay is drawn
	 * onto the image representing the different
	 * masks (each mask has its own color). It can
	 * be very useful to check your mapping. This
	 * feature is for debug purpose only. The overlay
	 * rendering is very slow and CPU consuming.
	 *
	 * @param enabled true to enable the debug overlay.
	 * @attr ref fr.bigint.imagemask.R.styleable#MaskMapImageView_mask_showDebugOverlay
	 */
	public void setDebugOverlayEnabled(boolean enabled) {
		if (enabled != mDebugOverlayEnabled) {
			mDebugOverlayEnabled = enabled;
			if (mDebugOverlay != null) {
				invalidate();
			}
		}
	}

	private void onDebugOverlayReady(int[] debugOverlay) {
		mDebugOverlay = debugOverlay;
		if (mDebugOverlayEnabled) {
			invalidate();
		}
	}

	/**
	 * Registers an {@link OnMaskTouchListener}.
	 *
	 * @param onMaskTouchListener listener to regiter
	 */
	public void setOnMaskTouchListener(OnMaskTouchListener onMaskTouchListener) {
		mOnMaskTouchListener = onMaskTouchListener;
	}

	/**
	 * Listener interface used to communicate
	 * touch events matching mapping masks.
	 */
	public static interface OnMaskTouchListener {
		/**
		 * Called when an {@link android.view.MotionEvent#ACTION_DOWN}
		 * has been detected on a mask. You can
		 * recognize which mask has been pressed
		 * using the passed drawable id and tag.
		 *
		 * @param mask Drawable that has been used
		 *             to create the pressed mask.
		 * @param tag  Tag associated to the pressed mask.
		 */
		public void onMaskPressed(@DrawableRes int mask, Object tag);

		/**
		 * Called when a mask is no longer pressed.
		 * It means that {@link #onMaskPressed(int, Object)}
		 * has already been called for this mask.
		 * If this event is triggered by an {@link android.view.MotionEvent#ACTION_UP},
		 * {@link #onMaskClick(int, Object)} will be
		 * called subsequently.
		 * You can recognize which mask has been pressed
		 * using the passed drawable id and tag.
		 *
		 * @param mask Drawable that has been used
		 *             to create the unpressed mask.
		 * @param tag  Tag associated to the unpressed mask.
		 */
		public void onMaskUnpressed(@DrawableRes int mask, Object tag);

		/**
		 * Called when a mask is clicked.
		 * It means that {@link #onMaskPressed(int, Object)}
		 * and {@link #onMaskUnpressed(int, Object)}
		 * have already been called for this mask.
		 * You can recognize which mask has been clicked
		 * using the passed drawable id and tag.
		 *
		 * @param mask Drawable that has been used
		 *             to create the clicked mask.
		 * @param tag  Tag associated to the clicked mask.
		 */
		public void onMaskClick(@DrawableRes int mask, Object tag);
	}


	/**
	 * Worker that initiates a debug overlay.
	 *
	 * @see #setDebugOverlayEnabled
	 */
	private static class InitDebugOverlayTask extends AsyncTask<Mask, Void, int[]> {

		private final int mWidth;
		private final int mHeight;
		private WeakReference<MaskMapImageView> mMaskMapImageViewReference;

		public InitDebugOverlayTask(@NonNull MaskMapImageView maskMapImageView, int width, int height) {
			mMaskMapImageViewReference = new WeakReference<MaskMapImageView>(maskMapImageView);
			mWidth = width;
			mHeight = height;
		}

		@Override
		protected int[] doInBackground(Mask... masks) {
			int[] overlay;
			int[] colors = getDebugOverlayColors(masks.length);
			overlay = new int[mWidth * mHeight];

			for (int i = 0; i < mHeight; i++) {
				MaskMapImageView maskMapImageView = mMaskMapImageViewReference.get();
				if (maskMapImageView == null) {
					cancel(true);
				}
				if (isCancelled()) {
					return null;
				}

				for (int j = 0; j < mWidth; j++) {
					int color;
					Mask matchingMask = maskMapImageView.getMatchingMask(j + 0.5f, i + 0.5f);
					if (matchingMask != null) {
						color = 0x70FF0000;
						for (int k = 0; k < masks.length; k++) {
							if (masks[k] == matchingMask) {
								color = colors[k];
								break;
							}
						}
					} else {
						color = 0x00000000;
					}
					overlay[i * mWidth + j] = color;
				}
			}

			return overlay;
		}

		@Override
		protected void onPostExecute(int[] overlay) {
			if (mMaskMapImageViewReference != null && overlay != null) {
				final MaskMapImageView maskMapImageView = mMaskMapImageViewReference.get();
				if (maskMapImageView != null) {
					maskMapImageView.onDebugOverlayReady(overlay);
				}
			}
		}

		/**
		 * Generates an array of (count) different colors
		 *
		 * @param count number of colors to generate
		 * @return an array of (count) different colors
		 */
		private int[] getDebugOverlayColors(int count) {
			int[] colors = new int[count];
			for (int i = 0; i < count; i++) {
				double hue = ((float) i / count) * 0.7 + 0.3;
				double red = hue * 2 * Math.PI + 0.55 * (2 * Math.PI);
				double green = (hue * 2 * Math.PI + Math.PI / 2) % (2 * Math.PI) + 0.55 * (2 * Math.PI);
				double blue = (hue * 2 * Math.PI + Math.PI - 0.0001) % (2 * Math.PI) + 0.55 * (2 * Math.PI);
				red = (Math.cos(red) + 1) / 2 * 255;
				green = (Math.cos(green) + 1) / 2 * 210;
				blue = (Math.cos(blue) + 1) / 2 * 230;

				colors[i] = (0x70 << 24) + ((int) red << 16) + ((int) green << 8) + (int) blue;
			}
			return colors;
		}
	}
}
